// Require bcrypt
const bcrypt = require('bcrypt');

// Require model User
const User = require('./../models/User.js');

// require validator
const Validator = require('./validator');
const FlashOldInput = require('./.')

// Objek Register User
const RegisterUser = {

    // fungsi registrasi
    register: function(req, res) {

        // menjalankan fungsi validateRegister
        RegisterUser.validateRegister(req, res, (err, result, oldInput) => {
            if(err) {
                for (const key in oldInput) {
                    req.flash(`old${key}`, oldInput[key]);
                }
                req.flash(result.input, result.message);
                res.redirect('/user/register');
            }
        });

        // melakukan validasi input
        Validator(req, {
            nama: 'required|min:3|max:50',
            email: 'required|min:3|max:50',
            username: 'required|min:4|max:50',
            password: 'required|equal:password_confirmation|min:6',
        }, (err, result) => {
            if(err) {
                for (const key in req.body) {
                    req.flash(`old${key}`, req.body[key]);
                }
                req.flash(result.input, result.message);
                res.status(200);
                res.redirect('/user/register');
            }
        });

        // menjalankan fungsi untuk create user
        RegisterUser.createUser(req, res, (err, result) => {
            if(err) throw err;
            res.redirect('/');
        });

    },

    // fungsi validateRegister
    validateRegister: function(req, res, callback) {

        // cari berdasarkan email
        User.findByEmail(req.body.email, (err, result) => {
            // Check if query is error
            if(err) throw err;
            
            // check if email is already exists
            if(result.length > 0) {
                callback(true, {
                    input: 'email',
                    message: 'email sudah digunakan',
                }, req.body);
            }
        });

        // cari berdasarkan username
        User.findByUsername(req.body.username, (err, result) => {
            // check if query is error
            if(err) throw err;

            // check if username is already exists
            if(result.length > 0) {
                callback(true, {
                    input: 'username',
                    message: 'username sudah digunakan',
                }, req.body);
            }
        });
    },

    // fungsi create user
    createUser: function(req, callback) {
        // material for hash password
        const saltRound = 10;
        const password = req.body.password;

        // hashing password
        bcrypt.hash(password, saltRound, (err, hash) => {
            if(err) throw err;

            // Create User
            User.create({
                nama: req.body.nama,
                email: req.body.email,
                username: req.body.username,
                password: hash,
            }, (err, result) => {
                if(err) throw err;
            });
        });
    }
}

// export
module.exports = RegisterUser;

















        // User.findByColumn('email', req.body.email, (result) => {
        //     if(result.length > 0 ) {
        //         const oldInput = req.body;
                
        //         FlashOldInput(req);
        //         req.flash('email', 'email sudah digunakan');
        //         res.redirect('/user/register');
        //     } else {
        //         // material for hash password
        //         const saltRound = 10;
        //         const password = req.body.password;

        //         // hashing password
        //         bcrypt.hash(password, saltRound, (err, hash) => {
        //             if(err) throw err;
                    
        //             User.create({
        //                 nama: req.body.nama,
        //                 email: req.body.email,
        //                 username: req.body.username,
        //                 password: hash,
        //             });

        //             req.flash('success', 'Registrasi akun');
        //             res.redirect('/user/login');
        //         })
        //     }
        // });




















                  // // Validate image upload
            // FilesValidation(files, {
            //     design: 'extension:jpg, jpeg, png, bmp, gif, svg|maxsize:2500|required:true',
            // }, (error, result) => {
            //     if(error) {
            //         req.body = fields;
            //         is_error = {
            //             req: req,
            //             input: result.input,
            //             message: result.message
            //         }
            //     }
            // });

            // // Validate input
            // await AsyncValidator(fields, {
            //     title: 'required|max:25|unique:Design.title',
            //     design_category_id: 'required|in:design_categories.id',
            // }).then((results) => {
            //     req.body = fields;
            //         is_error = {
            //             req: req,
            //             input: results.input,
            //             message: results.message
            //         }
            // })

            // // Pass validation let's upload and insert to database
            // const imageName = `${fields.title}-${Math.floor(100000 + Math.random() * 900000)}.${files.design.name.split('.')[files.design.name.split('.').length - 1]}`;
            // const oldPath   = files.design.path;
            // const newPath   = path.join(__dirname, './../public/images/designs/' + imageName)
            // const rawData = fs.readFileSync(oldPath) 

            // // Upload image
            // fs.writeFile(newPath, rawData, function(err){ 
            //     if(err) throw err;
            // });

            // // Insert data to database
            // Design.create({
            //     user_id: 101,
            //     design_category_id: fields.design_category_id,
            //     title: fields.title,
            //     design: imageName,
            // });

            // // Redirect
            // res.end();
































            const FilesValidation = function(files, rules, callback) {
    
    // Looping rules object to get each rule (row)
    for (const key in rules) {
        if (rules.hasOwnProperty(key)) {

            // Create variable to contain each file
            const file = files[key];

            // Explode rule (row) to get rule (each rule)
            const eachRule = rules[key].split('|');

            // Looping eachRule to get rule (one rule)
            eachRule.forEach( (e)=> {                
                // Explode each of eachRule variable and create variable to contain rule and values
                const [rule, values] = e.split(':');

                // Validaton if rule is required
                if(rule == 'required') {
                    if(file.size == 0 || file.name == '') {
                        callback(true, {
                            input: key, 
                            message: `${key} tidak boleh kosong`}); 
                    }
                }

                // Validation if rule is extension
                if(rule == 'extension') {
                    const arrExtensionValid = values.split(',').map((e) => e.replace(' ', ''));
                    const extensionFile = file.name.split('.')[file.name.split('.').length - 1];

                    if(!arrExtensionValid.includes(extensionFile)) {
                        return callback(true, {
                            input: key, 
                            message: `File yang kamu upload, harus berekstensi ${arrExtensionValid.join(', ')}`
                        }); 
                    } 
                }

                // Validation if rule is max size
                if(rule == 'maxsize') {
                    const filesize = file.size;
                    const maxsize = values;

                    if(filesize > maxsize * 1000) {
                        return callback(true, {
                            input: key,
                            message: `File maksimal berukuran ${maxsize} KB`
                        }); 
                    } 
                }
            });
        }
    }

}

module.exports = FilesValidation;































const AsyncValidator = (req, object) => {
    return new Promise(async(resolve, reject) => {
        try {
            // melakukan perulangan kepada object sehingga mendapatkan masing2 properti
            for(const key in object) {
                if (object.hasOwnProperty(key)) {
        
                    // mendapatkan rules
                    const rules = object[key];
        
                    // memecah rules dengan delimiter yaitu |
                    const rulesArr = rules.split('|');
        
                    // melakukan perulangan terhadap rules yang dipecah tadi
                    rulesArr.forEach((rule) => {
        
                        // pengecekan kondisi jika required
                        if(rule == 'required') {
                            if(req[key] == '') {
                                resolve({
                                    input: key,
                                    message: `${key} tidak boleh kosong`,
                                })
                            }
                        }
        
                        // selain dari diatas berarti rule memiliki nilai value
                        else {
                            const ruleWithVal = rule.split(':');
        
                            // pengecekan kondisi jika ada batas minimal
                            if(ruleWithVal[0] == 'min') {
                                if(parseInt(req[key].length) < parseInt(ruleWithVal[1])) {
                                    resolve({
                                        input: key,
                                        message: `${key} minimal ${parseInt(ruleWithVal[1])} karakter`,
                                    })
                                }
                            }
        
                            // pengecekan kondisi jika ada batas maksimal
                            if(ruleWithVal[0] === 'max') {
                                if(parseInt(req[key].length) > parseInt(ruleWithVal[1])) {
                                    resolve({
                                        input: key,
                                        message: `${key} maksimal ${parseInt(ruleWithVal[1])} karakter`,
                                    })
                                }
                            }
        
                            // pengecekan kondisi jika harus sama dengan (equal)
                            if(ruleWithVal[0] == 'equal') {
                                if(req[key] != req[ruleWithVal[1]]) {
                                    resolve({
                                        input: key,
                                        message: `${key} dan ${ruleWithVal[1]} tidak cocok`,
                                    })
                                }
                            }
        
                            // Pengecekan jika data harus unik
                            if(ruleWithVal[0] == 'unique') {
                                const [table, column] = ruleWithVal[1].split('.');
                                const Model = require('./../models/' + table);
    
                                Model.findByColumn(column, req[key])
                                    .then((results) => {
                                        if(results) {
                                            resolve({
                                                input: key,
                                                message: `${key} sudah digunakan`, 
                                            })
                                        }
                                    })
                            }
                        }
                    })
                }
            }
        } catch (error) {
            reject(error);
        }
    });
}


module.exports = AsyncValidator;



















































// Fungsi validasi
const Validator = (req, object, callback, files = null) => {

    // melakukan perulangan kepada object sehingga mendapatkan masing2 properti
    for(const key in object) {
        if (object.hasOwnProperty(key)) {

            // mendapatkan rules
            const rules = object[key];

            // memecah rules dengan delimiter yaitu |
            const rulesArr = rules.split('|');

            // melakukan perulangan terhadap rules yang dipecah tadi
            rulesArr.forEach(async (rule) => {

                // pengecekan kondisi jika required
                if(rule == 'required') {
                    if(req[key] == '') {
                        callback(true, {
                            input: key,
                            message: `${key} tidak boleh kosong`,
                        })
                    }
                }

                // selain dari diatas berarti rule memiliki nilai value
                else {
                    const ruleWithVal = rule.split(':');

                    // pengecekan kondisi jika ada batas minimal
                    if(ruleWithVal[0] == 'min') {
                        if(parseInt(req[key].length) < parseInt(ruleWithVal[1])) {
                            callback(true, {
                                input: key,
                                message: `${key} minimal ${parseInt(ruleWithVal[1])} karakter`,
                            });
                        }
                    }

                    // pengecekan kondisi jika ada batas maksimal
                    if(ruleWithVal[0] === 'max') {
                        if(parseInt(req[key].length) > parseInt(ruleWithVal[1])) {
                            callback(true, {
                                input: key,
                                message: `${key} maksimal ${parseInt(ruleWithVal[1])} karakter`,
                            });
                        }
                    }

                    // pengecekan kondisi jika harus sama dengan (equal)
                    if(ruleWithVal[0] == 'equal') {
                        if(req[key] != req[ruleWithVal[1]]) {
                            callback(true, {
                                input: key,
                                message: `${key} dan ${ruleWithVal[1]} tidak cocok`,
                            });
                        }
                    }

                    // Pengecekan jika data harus unik
                    if(ruleWithVal[0] == 'unique') {
                        (async()=> {
                            const [table, column] = ruleWithVal[1].split('.');
                            const Model = require('./../models/' + table);
    
                            await Model.findByColumn(column, req[key])
                                .then((results) => {
                                    if(results) {
                                        callback(true, {
                                            input: key,
                                            message: `${key} sudah digunakan`,
                                        });
                                    }
                                })
                                .catch((error) => {throw error})
                        })();
                    }
                }
            })
        }
    }
};

module.exports = Validator;